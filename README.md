# Содержание
1. [Цель работы](#цель-работы)
2. [Введение](#введение)
	1. [Теоретическая справка](#теор-справка)
	2. [Постановка задачи](#постановка)
3. [Материалы и методы](#мат-и-мет)
	1. [Хеш-функции](#хеш-функции)
	2. [Тесты](#тесты)
		1. [Распределение функций](#распр-функ)
		2. [Ускорение поиска](#ускор-поиска)
4. [Ход работы](#ход-работы)
5. [Результаты измерений](#рез-измер)
	1. [Распределение функций](#рез-распр)

# Цель работы  <a name="цель-работы"/>

Изучить устройство хеш-таблиц и способы их оптимизации на конкретной задаче поиска слов во множестве.

# Введение <a name="введение" />

## Теоретическая справка <a name="теор-справка" />

***Хеш-таблица*** - это структура данных, позволяющая хранить произвольное множество ключей.

Она позволяет осуществлять следующие операции:
1. Добавить ключ в таблицу
2. Проверить наличие ключа в таблице

***Хеш-функция*** - это функция, с помощью которой производится сопоставление множествам ключей множество натуральных чисел - хешей. По хешу во внутренней структуре хеш-таблицы осуществляется поиск элемента.

К сожалению, хеш-функция не всегда осуществляет однозначное отображение, она может для разных объектов выдать одинаковое число. Такая ситуация называется ***коллизией***.
Хеш-функция должна равномерно распределять множество ключей по таблице. "Равномерно" в данном случае обозначает то, что в таблице не должно быть больших скоплений элементов по одному хешу относительно других.

Для разрешения коллизий существует ***метод цепочек***. Он заключается в том, что в каждой ячейке таблицы мы храним список, в котором перечислены все элементы, имеющие данное значение хеша. Тогда при поиске элемента осуществляется вычисление хеша и поиск в соответствующем списке.

Таким образом, чтобы обеспечить быстрый доступ к элементу, необходимо делать длину списков такой маленькой, насколько это возможно.

Ещё одно важное понятие, к которому мы будем обращаться в работе в дальнейшем, это операция ***рехеширования***. Она происходит путём увеличения размера таблицы и перераспределения по ней уже имеющихся элементов. Эта процедура, в основном, используется для уменьшения длин итоговых списков. 

## Постановка задачи <a name="постановка" />

Работа состоит из двух частей. В **первой части** исследуется набор хеш-функций, а именно то, как они распределяют введенные ключи по таблице. 
Во **второй части** производится оптимизация работы хеш-таблицы на тесте, заключающемся в поиске случайных слов по таблице.

# Материалы и методы <a name="мат-и-мет" />

## Хеш-функции <a name="хеш-функции" />

Для анализа были выбраны следующие хеш-функции:
1. **const** - функция, возвращающая всегда число 1
2. **first_char** - возвращает ASCII-код первого символа строки
3. **strlen** - возвращает длину строки
4. **sum_char** - возвращает сумму ASCII-кодов символов строки
5. **rotr** - функция, устроенная следующим образом:

<details>
<summary>Описание</summary>

Пусть `h[0] = 0`. Тогда `h[i] = ROTR(h[i - 1]) XOR str[i - 1]`, где

`ROTR` - функция, осуществляющая циклический побитовый сдвиг вправо. Например, 8-битное беззнаковое число 43, которое имеет в двоичной записи вид 00101011, превращается в 10010101, равное 149

 `str` - строка, хеш которой считается
 
 В итоге хеш-функция **hash_rotr** возвращает `h[n]`, где `n` - длина строки
 
</details>

6. **rotl** - функция, аналогичная предыдущей, только с использованием циклического побитового сдвига влево
7. **crc32** - расшифровка: **C**yclic **R**edundancy **C**ode, или циклический избыточный код

Для ознакомления с последней хеш-функцией заинтересованному читателю предлагается прочитать следующие материалы:
- [A painless guide to CRC error detection algorithms](http://www.ross.net/crc/download/crc_v3.txt)
- [Английская википедия](https://en.wikipedia.org/wiki/Computation_of_cyclic_redundancy_checks)

В статье не будет описан принцип работы последней функции, как и не будет поясняться код для её вычисления. Также будет использоваться тот факт, что инженеры процессоров предусмотрели аппаратную возможность вычисления этой функции.

## Тесты <a name="тесты" />

### Распределение функций <a name="распр-функ" />

Для оценки распределения хеш-функций программа запускается на наборе слов из файла [words.txt](assets/data/words.txt). В файле находится 58111 различных слов. Работа хеш-функции оценивается на нескольких размерах таблицы: 751, 2017, 4007, 8009. Это простые числа, они улучшают распределение хеш-функций.  Размеры подобраны таким образом, чтобы отследить поведение функций в различных ситуациях и выделить у них, например, такие свойства, как ограниченность. Полученные размеры списков записываются в dat файлы, по которым строятся гистограммы с помощью gnuplot.

### Ускорение поиска <a name="ускор-поиска" />

Используется тот же файл, что и для оценки распределения хеш-функций. Тест заключается в поиске случайных слов из файла. Поиск запускается 20 млн раз. 

*Примечание*: при подготовке к тестированию слова вносятся в хеш-таблицу с учётом операции рехеширования, чтобы использовать оптимальные длины списков (в среднем не более 5 элементов). Чтобы не учитывать влияние ввода слов, поиск как раз и запускается 20 млн раз. Так можно пренебречь временем вставки слов в таблицу и учитывать именно время поиска.

Время работы программы замеряется с использованием утилиты perf stat. Профилирование производится с использованием gprof.

# Ход работы <a name="ход-работы" />

1. Была реализована хеш-таблица с использованием cache-friendly списков, написанных отдельным проектом в первом семестре
2. Списки были переписаны с идеей собственного аллокатора, то есть отдельной структуры, которая отвечает за выделение памяти под элементы массива в едином связном куске памяти
3. Хеш-таблица была протестированы с использованием набора функций, представленных выше
4. Длины каждого из списков были записаны в отдельный файл и представлены в виде столбчатых диаграмм
5. Были произведены повторные замеры с увеличенным размером таблицы
6. Была выбрана наиболее оптимальная хеш-функция под задачу
7. На хеш-таблице с выбранной хеш-функцией были произведены тесты по поиску элементов
8. Полученные результаты записаны как результаты ***базовой версии***
9. Произведено профилирование ***базовой версии*** с целью выявления наиболее времязатратных мест программы
10. Проведён ряд оптимизацией, подробнее о котором сказано в дальнейшем
11. Все версии программ перетестированы
16. Все результаты тестирования были внесены в общую таблицу для сравнения и определения ускорения, которого мы добились в ходе оптимизаций
17. Получен вывод и идеи по дальнейшей оптимизации хеш-таблиц

# Результаты измерений <a name="рез-измер" />

## Распределение функций <a name="рез-распр" />

### *const*

**Размер таблицы: 751**

![](./assets/pictures/hash_const_size_751.png)

Все слова из нашего файла сконцентрировались в одном списке, что и ожидалось. Рассматривать на других размерах таблицы не требуется. По гистограмме видно, что распределение не подходит для хорошей хеш-функции.

### *first_char* 

**Размер таблицы: 751**

![](./assets/pictures/hash_first_char_size_751.png)

Данная функция является ограниченной. Используются лишь списки с номерами от ASCII-кода буквы 'a' до буквы 'z'. На таблице большего размера 

### *strlen* 

**Размер таблицы: 751**

![](./assets/pictures/hash_strlen_size_751.png)

Данная функция является ограниченной. Гистограмма в действительности показывается распределение длин слов в английском языке.

### *sum_char*

**Размер таблицы: 751**

![](./assets/pictures/hash_sum_char_size_751.png)

Из данной гистограммы может показаться, что функция не такая и плохая, но предлагаем рассмотреть распределение функции на таблице большего размера.

**Размер таблицы: 8009**

![](./assets/pictures/hash_sum_char_size_8009.png)

На гистограмме для размера таблицы 8009 отчетливо видно, что данная функция тоже является ограниченной. 
 
### *rotr*

**Размер таблицы: 2017**

![](./assets/pictures/hash_rotr_size_2017.png)

Функция имеет части, в которых скапливается больше всего элементов. Рассмотрим данную особенность на таблице большего размера.

**Размер таблицы: 8009**

![](./assets/pictures/hash_rotr_size_8009.png)

На данной гистограмме отчетливо видно скачки длин списков в таблице.

### *rotl*

**Размер таблицы: 2017**

![](./assets/pictures/hash_rotl_size_2017.png)

Данная функция имеет распределение лучше, чем у предыдущей, которая отличается от неё лишь направлением сдвига. К сожалению, функция имеет волнообразный характер. Рассмотрим на таблице большего размера.

**Размер таблицы: 8009**

![](./assets/pictures/hash_rotl_size_8009.png)

Такая же проблема, как и у предыдущей функции, - есть части, где происходит скопление элементов

### *crc32*

**Размер таблицы: 2017**

![](./assets/pictures/hash_crc32_size_2017.png)

Функция имеет подходящее для нашей задачи распределение. Удостоверимся на таблице большего размера.

**Размер таблицы: 8009**

![](./assets/pictures/hash_crc32_size_8009.png)

Она не является ограниченной, не имеет областей скопления. Функция действительно подходит нам для дальнейшей работы.

Для численной оценки работы хеш-таблиц приведём таблицу со среднеквадратическими отклонениями длин списков. Данные приведены для наибольшего из размеров таблицы, на которых проводилось тестирование, - 8009.

|                            | const | first_char | strlen | sum_char | rotr | rotl | crc32 |
|----------------------------|-------|------------|--------|----------|------|------|-------|
| **Стандартное отклонение**     | 600   | 200        | 200    | 30       | 8    | 5    | 3     |
| **Максимальная длина списков** | 58111 | 6670       | 9396   | 230      | 61   | 34   | 18    |

Исходя из рассмотренных гистограмм, видно, что нельзя руководствоваться только численными показателями. По таблице может показаться, что все последние четыре функции,а именно sum_char, rotr, rotl, crc32 могут нам подойти в силу низкого отклонения, однако ранее мы рассмотрели их недостатки. Таким образом, во второй части работы будет использоваться функция crc32.

## Ускорение таблиц

В данном разделе результатах профилирования приведена лишь значимая для анализа часть. Полные результаты профилирования можно найти в папке по [ссылке](./assets/data/hash_funs/speed/)
### Базовая версия

<details>
<summary>Результаты тестирования</summary>

```
           # Table of individual measurements:
            2,4329 (+0,0169) #
            2,3759 (-0,0400) #
            2,3398 (-0,0761) #
            2,3613 (-0,0546) #
            2,4154 (-0,0006) #
            2,4127 (-0,0033) #
            2,3817 (-0,0342) #
            2,4451 (+0,0291) #
            2,4741 (+0,0582) #
            2,5207 (+0,1047) #

            # Final result:
            2,4160 +- 0,0173 seconds time elapsed  ( +-  0,72% )
```

</details>

<details>
<summary> Результаты профилирования </summary>

```
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 90.87      1.89     1.89 20145379     0.00     0.00  HashTableFind(HashTable*, char const*, unsigned int*)
  4.81      1.99     0.10 20145379     0.00     0.00  hash_crc32(char const*)
  1.92      2.03     0.04        1     0.04     2.04  HashTableSpeedTestExec_(HashTableSpeedTest*, unsigned int (*)(char const*), char const*, unsigned int)
  1.92      2.07     0.04                             _init
  0.48      2.08     0.01    65537     0.00     0.00  ListCtor(List*, BufferList*)
  0.00      2.08     0.00   210897     0.00     0.00  BufferListPop(BufferList*)
  0.00      2.08     0.00   145363     0.00     0.00  HashTableInsert(HashTable*, char const*)
  0.00      2.08     0.00   145360     0.00     0.00  ListPushBack(List*, char const*)
  0.00      2.08     0.00    87252     0.00     0.00  ListPopFront(List*)
  0.00      2.08     0.00    87252     0.00     0.00  BufferListAdd(BufferList*, int)
  0.00      2.08     0.00    65539     0.00     0.00  BufferListDtor(BufferList*)
  0.00      2.08     0.00    65537     0.00     0.00  ListDtor(List*)
  0.00      2.08     0.00       16     0.00     0.00  HashTableRehash(HashTable*, unsigned int)
```

</details>

По результатам профилирования **базовой версии** видно, что больше всего времени занимает  функция поиска. Было решено ускорить функцию сравнения строк. Для этого все строки после считывания были расширены и переупакованы по 32 символа. Этого хватит для нашей задачи, так как длина слов не превышает 22 символов. Таким образом, сравнение строк можно проводить при помощи AVX команд.

Фрагмент из функции поиска:
```
        __m256i str_lst = _mm256_load_si256((const __m256i*) ListGet(lst, curr_node)->val);

        uint16_t cmp_res = _mm256_cmpeq_epi8_mask(str_cpy, str_lst);
        if (!(~cmp_res))
            return curr_node;
```

### Версия №1

<details>
<summary> Результаты профилирования </summary>

```
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 68.18      0.30     0.30 20145379     0.00     0.00  hash_crc32(char const*)
 18.18      0.38     0.08 20000000     0.00     0.00  HashTableFind(HashTable*, char const*, unsigned int*)
  9.09      0.42     0.04        1    40.00   430.00  HashTableSpeedTestExec_(HashTableSpeedTest*, unsigned int (*)(char const*), char const*, unsigned int)
  2.27      0.43     0.01       16     0.62     0.62  BufferListRealloc(BufferList*, unsigned int)
  2.27      0.44     0.01                             _init
  0.00      0.44     0.00   210900     0.00     0.00  BufferListPop(BufferList*)
  0.00      0.44     0.00   145363     0.00     0.00  ListPushBack(List*, char const*)
  0.00      0.44     0.00   145363     0.00     0.00  HashTableInsert(HashTable*, char const*)
  0.00      0.44     0.00    87252     0.00     0.00  ListPopFront(List*)
  0.00      0.44     0.00    87252     0.00     0.00  BufferListAdd(BufferList*, int)
  0.00      0.44     0.00    65539     0.00     0.00  BufferListDtor(BufferList*)
  0.00      0.44     0.00    65537     0.00     0.00  ListCtor(List*, BufferList*)
  0.00      0.44     0.00    65537     0.00     0.00  ListDtor(List*)
  0.00      0.44     0.00       16     0.00     0.45  HashTableRehash(HashTable*, unsigned int)
  ```

</details>

В результатах профилирования **версии №1**  видно, что теперь наибольшее время работы программы занимает функция расчёта хеша. Принято решение переписать её на ассемблере в отдельный файл.

Приведём конкретные фрагменты функции.

С помощью AVX команд производится определение длины строки:
```
    vpxor           xmm0, xmm0, xmm0
    vpcmpeqb        ymm0, ymm0, yword [rdi]
    vpmovmskb       ecx, ymm0
    tzcnt           ecx, ecx
```

Была изменена логика расчёта хеша. Вместо того, чтобы считать его по байтам вручную, мы разбиваем строку на блоки по 4, 2 и 1 символа. Для каждого блока расчёт хеша производится при помощи SSE4.2 команд.

Фрагмент блочного расчёта:
```
	loop_32:
	    cmp ecx, 4
	    jb loop_16
	
	    crc32 eax, dword [rdi]
	    add   rdi, 4
	    sub   rcx, 4
	    jmp   loop_32
	
	loop_16:
```

<details>
<summary>Результаты тестирования</summary>

```
           # Table of individual measurements:
           1,08395 (+0,01765) #
           1,09046 (+0,02416) #
           1,05134 (-0,01496) #
           1,06256 (-0,00374) #
           1,07156 (+0,00526) #
           1,07665 (+0,01035) #
           1,04647 (-0,01983) #
           1,07414 (+0,00784) #
           1,05094 (-0,01536) #
           1,05494 (-0,01136) #

           # Final result:
           1,06630 +- 0,00482 seconds time elapsed  ( +-  0,45% )
```

</details>

### Версия №2

<details>
<summary>Результаты тестирования</summary>

```
           # Table of individual measurements:
           0,93228 (+0,02115) #
           0,89277 (-0,01835) #
           0,89962 (-0,01150) #
           0,88886 (-0,02226) #
           0,94198 (+0,03085) #
           0,89762 (-0,01350) #
           0,91772 (+0,00660) #
           0,89547 (-0,01566) #
           0,93000 (+0,01888) #
           0,91491 (+0,00379) #

           # Final result:
           0,91112 +- 0,00597 seconds time elapsed  ( +-  0,66% )
```

</details>

<details>
<summary> Результаты профилирования </summary>

```
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 25.00      0.13     0.13 20000000     0.00     0.00  HashTableFind(HashTable*, char const*, unsigned int*)
 17.31      0.22     0.09                             hash_crc32
 17.31      0.31     0.09                             loop_16
 15.38      0.39     0.08        1    80.00   230.00  HashTableSpeedTestExec_(HashTableSpeedTest*, unsigned int (*)(char const*), char const*, unsigned int)
  9.62      0.44     0.05                             loop_32
  3.85      0.46     0.02                             _init
  3.85      0.48     0.02                             loop_8
  1.92      0.49     0.01   145363     0.00     0.00  ListPushBack(List*, char const*)
  1.92      0.50     0.01       16     0.62     0.62  BufferListRealloc(BufferList*, unsigned int)
  1.92      0.51     0.01                             end
  1.92      0.52     0.01                             mv_seq
```

</details>

### Версия №3

<details>
<summary>Результаты тестирования</summary>

```
           # Table of individual measurements:
           0,44032 (+0,00871) #
           0,43657 (+0,00497) #
           0,42079 (-0,01082) #
           0,45065 (+0,01904) #
           0,42326 (-0,00834) #
           0,42673 (-0,00488) #
           0,42561 (-0,00600) #
           0,42486 (-0,00675) #
           0,42759 (-0,00402) #
           0,43968 (+0,00807) #

           # Final result:
           0,43161 +- 0,00305 seconds time elapsed  ( +-  0,71% )
```

</details>

<details>
<summary> Результаты профилирования </summary>

```
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 40.00      0.06     0.06 20145379     0.00     0.00  hash_crc32(char const*)
 33.33      0.11     0.05 20000000     0.00     0.00  HashTableFind(HashTable*, char const*, unsigned int*)
 20.00      0.14     0.03        1    30.00   150.00  HashTableSpeedTestExec_(HashTableSpeedTest*, unsigned int (*)(char const*), char const*, unsigned int)
  6.67      0.15     0.01       16     0.62     0.62  BufferListRealloc(BufferList*, unsigned int)
  0.00      0.15     0.00   210900     0.00     0.00  BufferListPop(BufferList*)
  0.00      0.15     0.00   145363     0.00     0.00  ListPushBack(List*, char const*)
  0.00      0.15     0.00   145363     0.00     0.00  HashTableInsert(HashTable*, char const*)
```

</details>